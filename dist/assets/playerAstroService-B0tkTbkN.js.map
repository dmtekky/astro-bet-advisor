{"version":3,"file":"playerAstroService-B0tkTbkN.js","sources":["../../src/lib/astroUtils.ts","../../src/lib/playerAstroService.ts"],"sourcesContent":["/**\n * Advanced astronomical utilities for the Full Moon Odds app\n */\nimport * as Astronomy from 'astronomy-engine';\nimport { \n  AspectType, \n  CelestialBody, \n  Dignity, \n  ZodiacSign, \n  Element, \n  Modality,\n  AspectPattern,\n  HouseSystem,\n  Aspect\n} from '../types/astrology';\n\n// Constants\nconst ZODIAC_SIGNS: ZodiacSign[] = [\n  'Aries', 'Taurus', 'Gemini', 'Cancer', \n  'Leo', 'Virgo', 'Libra', 'Scorpio', \n  'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'\n];\n\nconst PLANETS = [\n  'Sun', 'Moon', 'Mercury', 'Venus', 'Mars',\n  'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto'\n];\n\nconst ELEMENTS: Record<Element, ZodiacSign[]> = {\n  fire: ['Aries', 'Leo', 'Sagittarius'],\n  earth: ['Taurus', 'Virgo', 'Capricorn'],\n  air: ['Gemini', 'Libra', 'Aquarius'],\n  water: ['Cancer', 'Scorpio', 'Pisces']\n};\n\nconst MODALITIES: Record<Modality, ZodiacSign[]> = {\n  cardinal: ['Aries', 'Cancer', 'Libra', 'Capricorn'],\n  fixed: ['Taurus', 'Leo', 'Scorpio', 'Aquarius'],\n  mutable: ['Gemini', 'Virgo', 'Sagittarius', 'Pisces']\n};\n\nconst RULERSHIPS: Record<ZodiacSign, string> = {\n  'Aries': 'Mars',\n  'Taurus': 'Venus',\n  'Gemini': 'Mercury',\n  'Cancer': 'Moon',\n  'Leo': 'Sun',\n  'Virgo': 'Mercury',\n  'Libra': 'Venus',\n  'Scorpio': 'Pluto', // Traditional: Mars\n  'Sagittarius': 'Jupiter',\n  'Capricorn': 'Saturn',\n  'Aquarius': 'Uranus', // Traditional: Saturn\n  'Pisces': 'Neptune' // Traditional: Jupiter\n};\n\nconst EXALTATIONS: Record<string, ZodiacSign> = {\n  'Sun': 'Aries',\n  'Moon': 'Taurus',\n  'Mercury': 'Virgo',\n  'Venus': 'Pisces',\n  'Mars': 'Capricorn',\n  'Jupiter': 'Cancer',\n  'Saturn': 'Libra',\n  'Uranus': 'Scorpio',\n  'Neptune': 'Leo',\n  'Pluto': 'Aquarius'\n};\n\nconst DETRIMENTS: Record<string, ZodiacSign[]> = {\n  'Sun': ['Aquarius'],\n  'Moon': ['Capricorn'],\n  'Mercury': ['Sagittarius', 'Pisces'],\n  'Venus': ['Aries', 'Scorpio'],\n  'Mars': ['Taurus', 'Libra'],\n  'Jupiter': ['Gemini', 'Virgo'],\n  'Saturn': ['Cancer', 'Leo'],\n  'Uranus': ['Leo'],\n  'Neptune': ['Virgo'],\n  'Pluto': ['Taurus']\n};\n\nconst FALLS: Record<string, ZodiacSign> = {\n  'Sun': 'Libra',\n  'Moon': 'Scorpio',\n  'Mercury': 'Pisces',\n  'Venus': 'Virgo',\n  'Mars': 'Cancer',\n  'Jupiter': 'Capricorn',\n  'Saturn': 'Aries',\n  'Uranus': 'Taurus',\n  'Neptune': 'Aquarius',\n  'Pluto': 'Leo'\n};\n\nconst ASPECT_DEFINITIONS = [\n  { type: 'conjunction', angle: 0, orb: 8, influence: 'Strong', strength: 1.0 },\n  { type: 'opposition', angle: 180, orb: 8, influence: 'Strong', strength: 0.9 },\n  { type: 'trine', angle: 120, orb: 8, influence: 'Favorable', strength: 0.8 },\n  { type: 'square', angle: 90, orb: 7, influence: 'Challenging', strength: 0.7 },\n  { type: 'sextile', angle: 60, orb: 6, influence: 'Favorable', strength: 0.6 }\n];\n\n/**\n * Converts longitude to zodiac sign\n * @param longitude Celestial longitude in degrees\n * @returns Zodiac sign\n */\nexport function longitudeToSign(longitude: number): ZodiacSign {\n  const signIndex = Math.floor(longitude / 30) % 12;\n  return ZODIAC_SIGNS[signIndex];\n}\n\n/**\n * Gets the element of a zodiac sign\n * @param sign Zodiac sign\n * @returns Element (fire, earth, air, water)\n */\nexport function getElement(sign: ZodiacSign): Element {\n  for (const [element, signs] of Object.entries(ELEMENTS)) {\n    if (signs.includes(sign)) {\n      return element as Element;\n    }\n  }\n  throw new Error(`Invalid sign: ${sign}`);\n}\n\n/**\n * Gets the modality of a zodiac sign\n * @param sign Zodiac sign\n * @returns Modality (cardinal, fixed, mutable)\n */\nexport function getModality(sign: ZodiacSign): Modality {\n  for (const [modality, signs] of Object.entries(MODALITIES)) {\n    if (signs.includes(sign)) {\n      return modality as Modality;\n    }\n  }\n  throw new Error(`Invalid sign: ${sign}`);\n}\n\n/**\n * Calculates the dignity of a planet in a sign\n * @param planet Planet name\n * @param sign Zodiac sign\n * @returns Dignity information\n */\nexport function calculateDignity(planet: string, sign: ZodiacSign): Dignity {\n  const isRuler = RULERSHIPS[sign] === planet;\n  const isExaltation = EXALTATIONS[planet] === sign;\n  const isDetriment = DETRIMENTS[planet]?.includes(sign) || false;\n  const isFall = FALLS[planet] === sign;\n  \n  let score = 0;\n  if (isRuler) score += 5;\n  if (isExaltation) score += 4;\n  if (isDetriment) score -= 4;\n  if (isFall) score -= 5;\n  \n  return {\n    score,\n    status: {\n      ruler: isRuler,\n      exaltation: isExaltation,\n      detriment: isDetriment,\n      fall: isFall\n    }\n  };\n}\n\n/**\n * Calculates aspects between two celestial bodies\n * @param body1 First celestial body\n * @param body2 Second celestial body\n * @returns Aspect or null if no aspect is found\n */\nexport function calculateAspect(body1: CelestialBody, body2: CelestialBody): Aspect | null {\n  const lon1 = body1.longitude;\n  const lon2 = body2.longitude;\n  \n  // Calculate the angle between the two bodies\n  let angle = Math.abs(lon1 - lon2);\n  if (angle > 180) angle = 360 - angle;\n  \n  // Check if any aspect is within orb\n  for (const aspectDef of ASPECT_DEFINITIONS) {\n    const orb = Math.abs(angle - aspectDef.angle);\n    if (orb <= aspectDef.orb) {\n      // Calculate aspect strength based on exactness\n      const exactness = 1 - (orb / aspectDef.orb);\n      const strength = aspectDef.strength * exactness;\n      \n      return {\n        from: body1.name,\n        to: body2.name,\n        type: aspectDef.type as AspectType,\n        orb,\n        exact: orb < 1,\n        influence: {\n          description: `${body1.name} ${aspectDef.type} ${body2.name} (${orb.toFixed(1)}Â° orb)`,\n          strength,\n          area: getAspectAreas(body1.name, body2.name, aspectDef.type as AspectType)\n        }\n      };\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Gets life areas affected by an aspect\n * @param planet1 First planet\n * @param planet2 Second planet\n * @param aspectType Type of aspect\n * @returns Array of affected life areas\n */\nfunction getAspectAreas(planet1: string, planet2: string, aspectType: AspectType): string[] {\n  const planetAreas: Record<string, string[]> = {\n    'Sun': ['vitality', 'ego', 'identity', 'creativity'],\n    'Moon': ['emotions', 'instincts', 'habits', 'subconscious'],\n    'Mercury': ['communication', 'intellect', 'perception', 'learning'],\n    'Venus': ['relationships', 'values', 'aesthetics', 'harmony'],\n    'Mars': ['action', 'energy', 'aggression', 'drive'],\n    'Jupiter': ['expansion', 'growth', 'philosophy', 'optimism'],\n    'Saturn': ['discipline', 'restriction', 'responsibility', 'structure'],\n    'Uranus': ['innovation', 'rebellion', 'change', 'originality'],\n    'Neptune': ['spirituality', 'dreams', 'illusion', 'dissolution'],\n    'Pluto': ['transformation', 'power', 'rebirth', 'intensity']\n  };\n  \n  // Combine areas from both planets\n  const areas = [...(planetAreas[planet1] || []), ...(planetAreas[planet2] || [])];\n  // Return unique areas\n  return [...new Set(areas)].slice(0, 4); // Max 4 areas\n}\n\n/**\n * Detects aspect patterns in a chart\n * @param aspects List of aspects\n * @param planets Map of planets and their positions\n * @returns List of detected aspect patterns\n */\nexport function detectAspectPatterns(\n  aspects: Aspect[], \n  planets?: Record<string, CelestialBody>\n): AspectPattern[] {\n  const patterns: AspectPattern[] = [];\n  \n  // Grand Trine detection (3 planets in trine)\n  const trines = aspects.filter(a => a.type === 'trine');\n  if (trines.length >= 3) {\n    const planetNames = new Set<string>();\n    trines.forEach(t => {\n      planetNames.add(t.from);\n      planetNames.add(t.to);\n    });\n    \n    if (planetNames.size >= 3) {\n      // Simple detection - could be enhanced with more precise checks\n      const planetsArray = Array.from(planetNames).slice(0, 3);\n      \n      // If we have planet data, get the signs\n      let signs: ZodiacSign[] = [];\n      let elements: Element[] = [];\n      \n      if (planets) {\n        // Get signs from planet data\n        signs = planetsArray\n          .map(name => {\n            const key = name.toLowerCase();\n            return planets[key]?.sign as ZodiacSign;\n          })\n          .filter(Boolean) as ZodiacSign[];\n          \n        // Get elements from signs\n        elements = signs.map(getElement);\n      } else {\n        // Fallback if no planet data\n        signs = ['Aries', 'Leo', 'Sagittarius'] as ZodiacSign[];\n        elements = ['fire'] as Element[];\n      }\n      \n      // Check if all signs are of same element\n      const uniqueElements = [...new Set(elements)];\n      \n      if (uniqueElements.length === 1 || !planets) { // If no planet data, just create the pattern\n        patterns.push({\n          type: 'Grand Trine',\n          planets: planetsArray,\n          signs,\n          elements: uniqueElements,\n          influence: `Strong harmonious energy in ${uniqueElements[0] || 'fire'} element`,\n          strength: 0.8\n        });\n      }\n    }\n  }\n  \n  // More pattern detection can be added here\n  \n  return patterns;\n}\n\n/**\n * Calculates house positions using Placidus system\n * @param date Date for calculation\n * @param latitude Observer latitude\n * @param longitude Observer longitude\n * @returns House system data\n */\nexport function calculateHouses(date: Date, latitude: number, longitude: number): HouseSystem {\n  // Simplified implementation - in a real app, use a proper astronomy library\n  // This is a placeholder implementation\n  const cusps = Array(12).fill(0).map((_, i) => (i * 30) % 360);\n  \n  // Calculate approximate angles based on current time\n  const hours = date.getUTCHours() + date.getUTCMinutes() / 60;\n  const dayProgress = hours / 24;\n  const baseAngle = (dayProgress * 360 + 90) % 360;\n  \n  return {\n    system: 'Placidus',\n    cusps,\n    angles: {\n      asc: baseAngle,\n      mc: (baseAngle + 90) % 360,\n      dsc: (baseAngle + 180) % 360,\n      ic: (baseAngle + 270) % 360\n    }\n  };\n}\n\n/**\n * Checks if Mercury is retrograde\n * @param date Date to check\n * @returns Whether Mercury is retrograde\n */\nexport function isMercuryRetrograde(date: Date): boolean {\n  // This is a simplified check - in a real app, use an ephemeris\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  \n  // 2025 Mercury retrograde periods\n  const retrogradePeriods = [\n    { start: `${year}-01-14`, end: `${year}-02-03` },\n    { start: `${year}-05-10`, end: `${year}-06-02` },\n    { start: `${year}-09-09`, end: `${year}-10-02` },\n    { start: `${year}-12-29`, end: `${year+1}-01-18` }\n  ];\n  \n  const dateStr = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;\n  \n  return retrogradePeriods.some(period => \n    dateStr >= period.start && dateStr <= period.end\n  );\n}\n\n/**\n * Calculates moon phase (0-1)\n * @param date Date to calculate for\n * @returns Moon phase value between 0-1\n */\nexport function calculateMoonPhase(date: Date): number {\n  // Simplified moon phase calculation\n  const lunarCycle = 29.53; // days in lunar cycle\n  const knownNewMoon = new Date('2025-01-21T20:53:00Z').getTime();\n  const daysSinceKnownNewMoon = (date.getTime() - knownNewMoon) / (1000 * 60 * 60 * 24);\n  return (daysSinceKnownNewMoon % lunarCycle) / lunarCycle;\n}\n\n/**\n * Gets the name of a moon phase\n * @param phase Moon phase value (0-1)\n * @returns Name of the moon phase\n */\nexport function getMoonPhaseName(phase: number): string {\n  // Simple moon phase name lookup\n  if (phase < 0.03 || phase >= 0.97) return 'New Moon';\n  if (phase < 0.22) return 'Waxing Crescent';\n  if (phase < 0.28) return 'First Quarter';\n  if (phase < 0.47) return 'Waxing Gibbous';\n  if (phase < 0.53) return 'Full Moon';\n  if (phase < 0.72) return 'Waning Gibbous';\n  if (phase < 0.78) return 'Last Quarter';\n  return 'Waning Crescent';\n}\n\n/**\n * Calculates planetary position using astronomy-engine\n * @param body Celestial body\n * @param date Date for calculation\n * @param observer Observer location\n * @returns Celestial body data\n */\nexport function calculatePlanetaryPosition(\n  body: string, \n  date: Date, \n  observer: { latitude: number; longitude: number; altitude?: number }\n): CelestialBody {\n  try {\n    // This would use the actual astronomy-engine in a real implementation\n    // For now, we'll use a simplified approach\n    \n    // Convert body name to astronomy-engine body\n    const astronomyBody = mapToAstronomyBody(body);\n    \n    // Calculate position based on date\n    const dayOfYear = getDayOfYear(date);\n    const yearFraction = dayOfYear / 365;\n    \n    // Base longitude - simplified orbit calculation\n    const baseSpeed = getPlanetSpeed(body);\n    const basePeriod = getPlanetPeriod(body);\n    \n    // Calculate longitude - simplified\n    const longitude = (baseSpeed * yearFraction * 360) % 360;\n    \n    // Determine if retrograde (simplified)\n    const isRetrograde = body === 'Mercury' \n      ? isMercuryRetrograde(date)\n      : body === 'Venus' || body === 'Mars' || body === 'Jupiter' || body === 'Saturn'\n        ? Math.sin(yearFraction * Math.PI * 2 + Math.random() * 0.5) > 0.7\n        : false;\n    \n    // Calculate sign\n    const sign = longitudeToSign(longitude);\n    \n    // Calculate dignity\n    const dignity = calculateDignity(body, sign);\n    \n    return {\n      name: body,\n      longitude,\n      speed: baseSpeed * (isRetrograde ? -1 : 1),\n      sign,\n      degree: Math.floor(longitude % 30),\n      retrograde: isRetrograde,\n      dignity\n    };\n  } catch (error) {\n    console.error(`Error calculating position for ${body}:`, error);\n    // Return a fallback value\n    return {\n      name: body,\n      longitude: 0,\n      speed: 0,\n      sign: 'Aries',\n      degree: 0,\n      retrograde: false\n    };\n  }\n}\n\n// Helper function to get day of year\nfunction getDayOfYear(date: Date): number {\n  const start = new Date(date.getFullYear(), 0, 0);\n  const diff = date.getTime() - start.getTime();\n  return Math.floor(diff / (1000 * 60 * 60 * 24));\n}\n\n// Helper to map planet name to astronomy-engine body\nfunction mapToAstronomyBody(body: string): string {\n  const mapping: Record<string, string> = {\n    'Sun': 'Sun',\n    'Moon': 'Moon',\n    'Mercury': 'Mercury',\n    'Venus': 'Venus',\n    'Mars': 'Mars',\n    'Jupiter': 'Jupiter',\n    'Saturn': 'Saturn',\n    'Uranus': 'Uranus',\n    'Neptune': 'Neptune',\n    'Pluto': 'Pluto'\n  };\n  \n  return mapping[body] || body;\n}\n\n// Helper to get planet base speed\nfunction getPlanetSpeed(body: string): number {\n  const speeds: Record<string, number> = {\n    'Sun': 1,\n    'Moon': 13.2,\n    'Mercury': 1.2,\n    'Venus': 1.6,\n    'Mars': 0.5,\n    'Jupiter': 0.08,\n    'Saturn': 0.03,\n    'Uranus': 0.01,\n    'Neptune': 0.006,\n    'Pluto': 0.004\n  };\n  \n  return speeds[body] || 1;\n}\n\n// Helper to get planet orbital period in Earth years\nfunction getPlanetPeriod(body: string): number {\n  const periods: Record<string, number> = {\n    'Sun': 1,\n    'Moon': 0.0748, // ~27.3 days\n    'Mercury': 0.24,\n    'Venus': 0.62,\n    'Mars': 1.88,\n    'Jupiter': 11.86,\n    'Saturn': 29.46,\n    'Uranus': 84.01,\n    'Neptune': 164.79,\n    'Pluto': 248.59\n  };\n  \n  return periods[body] || 1;\n}\n\n/**\n * Calculates elemental balance in a chart\n * @param planets List of planets and their positions\n * @returns Elemental balance data\n */\nexport function calculateElementalBalance(\n  planets: Record<string, CelestialBody>\n): { \n  fire: { score: number; planets: string[] };\n  earth: { score: number; planets: string[] };\n  air: { score: number; planets: string[] };\n  water: { score: number; planets: string[] };\n} {\n  const elements: Record<Element, string[]> = {\n    fire: [],\n    earth: [],\n    air: [],\n    water: []\n  };\n  \n  // Count planets in each element\n  Object.entries(planets).forEach(([name, body]) => {\n    const element = getElement(body.sign);\n    elements[element].push(name);\n  });\n  \n  // Calculate scores\n  const total = Object.values(planets).length;\n  return {\n    fire: {\n      score: elements.fire.length / total,\n      planets: elements.fire\n    },\n    earth: {\n      score: elements.earth.length / total,\n      planets: elements.earth\n    },\n    air: {\n      score: elements.air.length / total,\n      planets: elements.air\n    },\n    water: {\n      score: elements.water.length / total,\n      planets: elements.water\n    }\n  };\n}\n\n/**\n * Calculates modality balance in a chart\n * @param planets List of planets and their positions\n * @returns Modality balance data\n */\nexport function calculateModalBalance(\n  planets: Record<string, CelestialBody>\n): { \n  cardinal: { score: number; planets: string[] };\n  fixed: { score: number; planets: string[] };\n  mutable: { score: number; planets: string[] };\n} {\n  const modalities: Record<Modality, string[]> = {\n    cardinal: [],\n    fixed: [],\n    mutable: []\n  };\n  \n  // Count planets in each modality\n  Object.entries(planets).forEach(([name, body]) => {\n    const modality = getModality(body.sign);\n    modalities[modality].push(name);\n  });\n  \n  // Calculate scores\n  const total = Object.values(planets).length;\n  return {\n    cardinal: {\n      score: modalities.cardinal.length / total,\n      planets: modalities.cardinal\n    },\n    fixed: {\n      score: modalities.fixed.length / total,\n      planets: modalities.fixed\n    },\n    mutable: {\n      score: modalities.mutable.length / total,\n      planets: modalities.mutable\n    }\n  };\n}\n","/**\n * Player Astrological Data Service\n * \n * This service provides astrological data for players based on their birth information.\n * It uses the player's birth date and location to calculate accurate astrological data.\n */\n\nimport { ZodiacSign, CelestialBody, ElementalBalance, ModalBalance } from '@/types/astrology';\nimport { longitudeToSign, getElement, getModality } from './astroUtils';\n\n// Zodiac signs in order\nconst ZODIAC_SIGNS: ZodiacSign[] = [\n  'Aries', 'Taurus', 'Gemini', 'Cancer', \n  'Leo', 'Virgo', 'Libra', 'Scorpio', \n  'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'\n];\n\n// Calculate sun sign based on birth date\nexport function calculateSunSign(birthDate: string): ZodiacSign {\n  const date = new Date(birthDate);\n  const month = date.getMonth();\n  const day = date.getDate();\n  \n  // Zodiac date ranges\n  if ((month === 2 && day >= 21) || (month === 3 && day <= 19)) return 'Aries';\n  if ((month === 3 && day >= 20) || (month === 4 && day <= 20)) return 'Taurus';\n  if ((month === 4 && day >= 21) || (month === 5 && day <= 20)) return 'Gemini';\n  if ((month === 5 && day >= 21) || (month === 6 && day <= 22)) return 'Cancer';\n  if ((month === 6 && day >= 23) || (month === 7 && day <= 22)) return 'Leo';\n  if ((month === 7 && day >= 23) || (month === 8 && day <= 22)) return 'Virgo';\n  if ((month === 8 && day >= 23) || (month === 9 && day <= 22)) return 'Libra';\n  if ((month === 9 && day >= 23) || (month === 10 && day <= 21)) return 'Scorpio';\n  if ((month === 10 && day >= 22) || (month === 11 && day <= 21)) return 'Sagittarius';\n  if ((month === 11 && day >= 22) || (month === 0 && day <= 19)) return 'Capricorn';\n  if ((month === 0 && day >= 20) || (month === 1 && day <= 18)) return 'Aquarius';\n  return 'Pisces';\n}\n\n// Calculate moon sign (simplified algorithm based on birth date)\nexport function calculateMoonSign(birthDate: string): ZodiacSign {\n  const date = new Date(birthDate);\n  // This is a simplified algorithm - in reality, moon sign calculation requires time and location\n  // For a more accurate calculation, we would need to use an ephemeris or astronomical calculations\n  const dayOfYear = getDayOfYear(date);\n  const moonCycle = 29.5; // days\n  const moonSignIndex = Math.floor((dayOfYear % (moonCycle * 12)) / moonCycle);\n  return ZODIAC_SIGNS[moonSignIndex % 12];\n}\n\n// Calculate ascendant based on birth date, time, and location\nexport function calculateAscendant(birthDate: string, birthCity?: string, birthCountry?: string): ZodiacSign {\n  // This is a simplified algorithm - in a production app, you'd use a proper ephemeris\n  // and house system calculation with exact time and coordinates\n  const date = new Date(birthDate);\n  \n  // If we have location data, we can make a slightly more informed guess\n  if (birthCity && birthCountry) {\n    // Use city and country to determine a more accurate ascendant\n    // This is still a simplification - in reality, we'd need coordinates and exact time\n    const locationHash = (birthCity + birthCountry).split('').reduce((acc, char) => {\n      return acc + char.charCodeAt(0);\n    }, 0);\n    \n    const dayOfYear = getDayOfYear(date);\n    const ascendantIndex = (dayOfYear + locationHash) % 12;\n    return ZODIAC_SIGNS[Math.abs(ascendantIndex) % 12];\n  }\n  \n  // Fallback to simple day-based calculation if no location data\n  const dayOfYear = getDayOfYear(date);\n  const ascendantIndex = dayOfYear % 12;\n  return ZODIAC_SIGNS[ascendantIndex];\n}\n\n// Calculate elemental balance based on sun, moon, and ascendant\nexport function calculateElementalBalance(\n  sunSign: ZodiacSign, \n  moonSign: ZodiacSign, \n  ascendant: ZodiacSign\n): ElementalBalance {\n  const elements = {\n    fire: { score: 0, planets: [] as string[], percentage: 0 },\n    earth: { score: 0, planets: [] as string[], percentage: 0 },\n    air: { score: 0, planets: [] as string[], percentage: 0 },\n    water: { score: 0, planets: [] as string[], percentage: 0 }\n  };\n  \n  // Assign scores based on the element of each sign\n  const sunElement = getElement(sunSign);\n  elements[sunElement].score += 5;\n  elements[sunElement].planets.push('Sun');\n  \n  const moonElement = getElement(moonSign);\n  elements[moonElement].score += 4;\n  elements[moonElement].planets.push('Moon');\n  \n  const ascElement = getElement(ascendant);\n  elements[ascElement].score += 3;\n  elements[ascElement].planets.push('Ascendant');\n  \n  // Calculate percentages\n  const totalScore = Object.values(elements).reduce((sum, el) => sum + el.score, 0);\n  \n  for (const element in elements) {\n    if (Object.prototype.hasOwnProperty.call(elements, element)) {\n      const percentage = totalScore > 0 \n        ? Math.round((elements[element as keyof typeof elements].score / totalScore) * 100) \n        : 25; // Default to equal distribution if no score\n      \n      elements[element as keyof typeof elements].percentage = percentage;\n    }\n  }\n  \n  return elements as ElementalBalance;\n}\n\n// Calculate modality balance based on sun, moon, and ascendant\nexport function calculateModalBalance(\n  sunSign: ZodiacSign, \n  moonSign: ZodiacSign, \n  ascendant: ZodiacSign\n): ModalBalance {\n  const modalities = {\n    cardinal: { score: 0, planets: [] as string[], percentage: 0 },\n    fixed: { score: 0, planets: [] as string[], percentage: 0 },\n    mutable: { score: 0, planets: [] as string[], percentage: 0 }\n  };\n  \n  // Assign scores based on the modality of each sign\n  const sunModality = getModality(sunSign);\n  modalities[sunModality].score += 5;\n  modalities[sunModality].planets.push('Sun');\n  \n  const moonModality = getModality(moonSign);\n  modalities[moonModality].score += 4;\n  modalities[moonModality].planets.push('Moon');\n  \n  const ascModality = getModality(ascendant);\n  modalities[ascModality].score += 3;\n  modalities[ascModality].planets.push('Ascendant');\n  \n  // Calculate percentages\n  const totalScore = Object.values(modalities).reduce((sum, mod) => sum + mod.score, 0);\n  \n  for (const modality in modalities) {\n    if (Object.prototype.hasOwnProperty.call(modalities, modality)) {\n      const percentage = totalScore > 0 \n        ? Math.round((modalities[modality as keyof typeof modalities].score / totalScore) * 100) \n        : 33; // Default to roughly equal distribution if no score\n      \n      modalities[modality as keyof typeof modalities].percentage = percentage;\n    }\n  }\n  \n  return modalities as ModalBalance;\n}\n\n// Calculate dominant planets based on sun and moon signs\nexport function calculateDominantPlanets(sunSign: ZodiacSign, moonSign: ZodiacSign) {\n  // Map of ruling planets for each sign\n  const rulerships: Record<ZodiacSign, string> = {\n    'Aries': 'Mars',\n    'Taurus': 'Venus',\n    'Gemini': 'Mercury',\n    'Cancer': 'Moon',\n    'Leo': 'Sun',\n    'Virgo': 'Mercury',\n    'Libra': 'Venus',\n    'Scorpio': 'Pluto', // Traditional: Mars\n    'Sagittarius': 'Jupiter',\n    'Capricorn': 'Saturn',\n    'Aquarius': 'Uranus', // Traditional: Saturn\n    'Pisces': 'Neptune' // Traditional: Jupiter\n  };\n  \n  // Get ruling planets\n  const sunRuler = rulerships[sunSign];\n  const moonRuler = rulerships[moonSign];\n  \n  // Create dominant planets array\n  const dominantPlanets = [\n    {\n      planet: sunRuler,\n      score: 5,\n      interpretation: `${sunRuler} rules ${sunSign}, influencing core identity and expression.`,\n      type: 'Ruler',\n      influence: 'Strong'\n    },\n    {\n      planet: moonRuler,\n      score: 4,\n      interpretation: `${moonRuler} rules ${moonSign}, affecting emotional responses and instincts.`,\n      type: 'Ruler',\n      influence: 'Strong'\n    }\n  ];\n  \n  // If sun and moon have the same ruler, add a third planet\n  if (sunRuler === moonRuler) {\n    // Add a third planet based on the element of the sun sign\n    const element = getElement(sunSign);\n    let thirdPlanet = '';\n    let interpretation = '';\n    \n    switch(element) {\n      case 'fire':\n        thirdPlanet = 'Mars';\n        interpretation = 'Mars amplifies the fiery energy, adding drive and competitive spirit.';\n        break;\n      case 'earth':\n        thirdPlanet = 'Saturn';\n        interpretation = 'Saturn enhances discipline and structure, adding stability and endurance.';\n        break;\n      case 'air':\n        thirdPlanet = 'Mercury';\n        interpretation = 'Mercury enhances mental agility, adding adaptability and quick thinking.';\n        break;\n      case 'water':\n        thirdPlanet = 'Neptune';\n        interpretation = 'Neptune deepens intuition and emotional sensitivity, adding creative vision.';\n        break;\n    }\n    \n    dominantPlanets.push({\n      planet: thirdPlanet,\n      score: 3,\n      interpretation,\n      type: 'Elemental',\n      influence: 'Moderate'\n    });\n  }\n  \n  return dominantPlanets;\n}\n\n// Determine astro weather based on birth date, location, and current transits\nexport function calculateAstroWeather(birthDate: string, birthCity?: string, birthCountry?: string): string {\n  const today = new Date();\n  const birth = new Date(birthDate);\n  \n  // Calculate lunar phase (0-1)\n  const lunarCycle = 29.53; // days\n  const daysSinceNewMoon = (Date.now() - new Date(today.getFullYear(), 0, 1).getTime()) / (1000 * 60 * 60 * 24) % lunarCycle;\n  const lunarPhase = daysSinceNewMoon / lunarCycle;\n  \n  // Calculate solar position (simplified)\n  const dayOfYear = getDayOfYear(today);\n  const solarPosition = (dayOfYear / 365) * 360; // 0-360 degrees\n  \n  // Calculate birth chart factors\n  const birthDayOfYear = getDayOfYear(birth);\n  const birthSolarPosition = (birthDayOfYear / 365) * 360;\n  \n  // Calculate angular distance between current sun and birth sun\n  let angleDiff = Math.abs(solarPosition - birthSolarPosition) % 360;\n  if (angleDiff > 180) angleDiff = 360 - angleDiff;\n  \n  // Location influence (simplified)\n  let locationFactor = 0.5; // Neutral default\n  if (birthCity && birthCountry) {\n    // Create a simple hash from location to influence the result\n    const locationStr = (birthCity + birthCountry).toLowerCase();\n    const locationHash = locationStr.split('').reduce((hash, char) => {\n      return (hash << 5) - hash + char.charCodeAt(0);\n    }, 0);\n    locationFactor = 0.3 + (Math.abs(locationHash) % 70) / 100; // 0.3 to 1.0\n  }\n  \n  // Calculate weather score (0-1)\n  const lunarInfluence = Math.sin(lunarPhase * Math.PI * 2); // -1 to 1\n  const solarInfluence = Math.cos(angleDiff * Math.PI / 180); // -1 to 1\n  const weatherScore = (lunarInfluence * 0.4 + solarInfluence * 0.6) * locationFactor;\n  \n  // Determine weather based on score\n  if (weatherScore > 0.3) return 'Favorable';\n  if (weatherScore < -0.3) return 'Challenging';\n  return 'Neutral';\n}\n\n// Helper function to get day of year\nfunction getDayOfYear(date: Date): number {\n  const start = new Date(date.getFullYear(), 0, 0);\n  const diff = date.getTime() - start.getTime();\n  const oneDay = 1000 * 60 * 60 * 24;\n  return Math.floor(diff / oneDay);\n}\n\n// Interface for birth location\nexport interface BirthLocation {\n  city?: string;\n  state?: string;\n  country?: string;\n}\n\n// Main function to generate astrological data for a player\nexport function generatePlayerAstroData(birthDate: string, location?: BirthLocation) {\n  if (!birthDate) {\n    throw new Error('Birth date is required');\n  }\n  \n  // Extract location data\n  const birthCity = location?.city;\n  const birthCountry = location?.country;\n  \n  // Calculate basic astrological data\n  const sunSign = calculateSunSign(birthDate);\n  const moonSign = calculateMoonSign(birthDate);\n  const ascendant = calculateAscendant(birthDate, birthCity, birthCountry);\n  \n  // Calculate astro weather with location data\n  const astroWeather = calculateAstroWeather(birthDate, birthCity, birthCountry);\n  \n  // Calculate derived data\n  const elements = calculateElementalBalance(sunSign, moonSign, ascendant);\n  const modalities = calculateModalBalance(sunSign, moonSign, ascendant);\n  const dominantPlanets = calculateDominantPlanets(sunSign, moonSign);\n  \n  // Generate moon phase data\n  const birthDateObj = new Date(birthDate);\n  \n  // Calculate moon phase (0 = new moon, 0.5 = full moon, 1 = next new moon)\n  const getMoonPhase = (date: Date): number => {\n    // Using a more robust calculation based on the current date\n    const synodicMonth = 29.530588853; // days in a synodic month (new moon to new moon)\n    // Get the current date in UTC to avoid timezone issues\n    const now = new Date(Date.UTC(\n      date.getUTCFullYear(),\n      date.getUTCMonth(),\n      date.getUTCDate(),\n      date.getUTCHours(),\n      date.getUTCMinutes(),\n      date.getUTCSeconds()\n    ));\n    \n    // Use a known new moon date relatively recent to avoid large number issues\n    const knownNewMoon = new Date(Date.UTC(2023, 0, 21, 20, 53, 0)); // Jan 21, 2023 20:53 UTC\n    \n    // Calculate days since known new moon\n    const msSinceNewMoon = now.getTime() - knownNewMoon.getTime();\n    const daysSinceNewMoon = msSinceNewMoon / (1000 * 60 * 60 * 24);\n    \n    // Calculate current phase (0-1)\n    let phase = (daysSinceNewMoon % synodicMonth) / synodicMonth;\n    \n    // Ensure phase is between 0 and 1\n    if (phase < 0) phase += 1;\n    \n    return phase;\n  };\n  \n  // Get moon phase info based on phase value (0-1)\n  const getMoonPhaseInfo = (phase: number) => {\n    if (phase < 0.03 || phase >= 0.97) return { name: 'New Moon', emoji: 'ðŸŒ‘' };\n    if (phase < 0.22) return { name: 'Waxing Crescent', emoji: 'ðŸŒ’' };\n    if (phase < 0.28) return { name: 'First Quarter', emoji: 'ðŸŒ“' };\n    if (phase < 0.47) return { name: 'Waxing Gibbous', emoji: 'ðŸŒ”' };\n    if (phase < 0.53) return { name: 'Full Moon', emoji: 'ðŸŒ•' };\n    if (phase < 0.72) return { name: 'Waning Gibbous', emoji: 'ðŸŒ–' };\n    if (phase < 0.78) return { name: 'Last Quarter', emoji: 'ðŸŒ—' };\n    return { name: 'Waning Crescent', emoji: 'ðŸŒ˜' };\n  };\n  \n  const moonPhaseValue = getMoonPhase(birthDateObj);\n  const { name: moonPhaseName } = getMoonPhaseInfo(moonPhaseValue);\n  \n  // Calculate simple aspects between Sun, Moon, and Ascendant\n  function getSimpleAspect(signA: ZodiacSign, signB: ZodiacSign): string | null {\n    const idxA = ZODIAC_SIGNS.indexOf(signA);\n    const idxB = ZODIAC_SIGNS.indexOf(signB);\n    let diff = Math.abs(idxA - idxB);\n    if (diff > 6) diff = 12 - diff;\n    if (diff === 0) return 'conjunction';\n    if (diff === 4) return 'trine';\n    if (diff === 2) return 'sextile';\n    if (diff === 6) return 'opposition';\n    if (diff === 3) return 'square';\n    return null;\n  }\n\n  const aspects = [\n    { pair: 'Sun-Moon', type: getSimpleAspect(sunSign, moonSign) },\n    { pair: 'Sun-Ascendant', type: getSimpleAspect(sunSign, ascendant) },\n    { pair: 'Moon-Ascendant', type: getSimpleAspect(moonSign, ascendant) }\n  ];\n\n  // Return complete astrological data that matches the AstroChartData interface\n  return {\n    date: birthDate,\n    planets: {\n      sun: {\n        name: 'Sun',\n        sign: sunSign,\n        degree: Math.floor(Math.random() * 30),\n        retrograde: false,\n        longitude: Math.floor(Math.random() * 360),\n        speed: 1.0 // Adding required speed property\n      },\n      moon: {\n        name: 'Moon',\n        sign: moonSign,\n        degree: Math.floor(Math.random() * 30),\n        retrograde: false,\n        longitude: Math.floor(Math.random() * 360),\n        speed: 13.2 // Adding required speed property (moon moves faster)\n      }\n    },\n    moonPhase: {\n      name: moonPhaseName,\n      value: moonPhaseValue,\n      illumination: moonPhaseValue < 0.5 ? moonPhaseValue * 2 : (1 - moonPhaseValue) * 2\n    },\n    elements,\n    modalities,\n    sunSign,\n    moonSign,\n    ascendant,\n    dominantPlanets,\n    astroWeather,\n    houses: {\n      ascendant: {\n        sign: ascendant,\n        degree: Math.floor(Math.random() * 30) // Adding required degree property\n      }\n    },\n    // Adding missing required properties\n    signs: {},\n    aspects\n  };\n}\n"],"names":["ELEMENTS","MODALITIES","getElement","sign","element","signs","getModality","modality","ZODIAC_SIGNS","calculateSunSign","birthDate","date","month","day","calculateMoonSign","dayOfYear","getDayOfYear","moonCycle","moonSignIndex","calculateAscendant","birthCity","birthCountry","locationHash","acc","char","ascendantIndex","calculateElementalBalance","sunSign","moonSign","ascendant","elements","sunElement","moonElement","ascElement","totalScore","sum","el","percentage","calculateModalBalance","modalities","sunModality","moonModality","ascModality","mod","calculateDominantPlanets","rulerships","sunRuler","moonRuler","dominantPlanets","thirdPlanet","interpretation","calculateAstroWeather","today","birth","lunarCycle","lunarPhase","solarPosition","birthSolarPosition","angleDiff","locationFactor","hash","lunarInfluence","solarInfluence","weatherScore","start","diff","oneDay","generatePlayerAstroData","location","astroWeather","birthDateObj","getMoonPhase","synodicMonth","now","knownNewMoon","phase","getMoonPhaseInfo","moonPhaseValue","moonPhaseName","getSimpleAspect","signA","signB","idxA","idxB","aspects"],"mappings":"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"}