{"version":3,"file":"useUpcomingGames-oenNZVZ7.js","sources":["../../src/hooks/useTeams.ts","../../src/hooks/useUpcomingGames.ts"],"sourcesContent":["import { useState, useEffect, useMemo } from 'react';\nimport { supabase } from '@/lib/supabase';\n\nexport interface Team {\n  id: string;\n  external_id: number;\n  name: string;\n  city: string;\n  abbreviation: string;\n  logo_url: string | null;\n  primary_color?: string | null;\n  secondary_color?: string | null;\n  // Add other fields as needed\n}\n\nexport function useTeams(leagueKey?: string) {\n  const [teams, setTeams] = useState<Team[]>([]);\n  const [loading, setLoading] = useState(true); // True initially, covers resolution + fetch\n  const [error, setError] = useState<Error | null>(null);\n  const [resolvedLeagueId, setResolvedLeagueId] = useState<string | null>(null);\n  const [isLeagueResolutionComplete, setIsLeagueResolutionComplete] = useState(false);\n\n  // Effect 1: Resolve league key to league ID\n  useEffect(() => {\n    // Reset resolution status when leagueKey changes\n    setIsLeagueResolutionComplete(false);\n    setResolvedLeagueId(null); // Clear previous resolved ID\n    async function resolve() {\n      if (!leagueKey) {\n        setResolvedLeagueId(null);\n        setIsLeagueResolutionComplete(true);\n        return;\n      }\n      \n      try {\n        console.log(`[useTeams] Looking up league with key: ${leagueKey}`);\n        \n        // First try to get from cache if available\n        const cacheKey = `league_${leagueKey}`;\n        const cachedLeague = localStorage.getItem(cacheKey);\n        \n        if (cachedLeague) {\n          try {\n            const leagueData = JSON.parse(cachedLeague);\n            console.log('[useTeams] Using cached league data:', leagueData);\n            setResolvedLeagueId(leagueData.id);\n            setIsLeagueResolutionComplete(true);\n            return;\n          } catch (e) {\n            console.warn('[useTeams] Error parsing cached league data, fetching fresh:', e);\n          }\n        }\n        \n        // If not in cache or invalid, fetch from API\n        const { data: leagueDataArray, error: leagueFetchError } = await supabase\n          .from('leagues')\n          .select('id, name, key')\n          .eq('key', leagueKey);\n\n        let leagueData = null;\n        let leagueError = leagueFetchError;\n\n        if (!leagueError && leagueDataArray) {\n          if (leagueDataArray.length > 1) {\n            console.error(`[useTeams] Multiple leagues found for key '${leagueKey}'. This indicates a data issue. Found:`, leagueDataArray);\n            // leagueData remains null, subsequent logic will treat as not found\n          } else if (leagueDataArray.length === 1) {\n            leagueData = leagueDataArray[0];\n          }\n        }\n        \n        if (leagueError || !leagueData) {\n          console.warn(`[useTeams] Could not find league with key: ${leagueKey}`, leagueError);\n          // Try a case-insensitive search as fallback\n          let caseInsensitiveData = null;\n          try {\n            const { data: caseInsensitiveArray, error: ilikeError } = await supabase\n              .from('leagues')\n              .select('id, name, key')\n              .ilike('key', leagueKey);\n            \n            if (!ilikeError && caseInsensitiveArray) {\n              if (caseInsensitiveArray.length > 1) {\n                console.error(`[useTeams] Multiple leagues found for case-insensitive key '${leagueKey}'. Found:`, caseInsensitiveArray);\n                // Treat as not found\n              } else if (caseInsensitiveArray.length === 1) {\n                caseInsensitiveData = caseInsensitiveArray[0];\n              }\n            } else if (ilikeError) {\n              console.warn('[useTeams] Case-insensitive league search itself failed:', ilikeError);\n            }\n          } catch (e) {\n            console.warn('[useTeams] Case-insensitive league search failed:', e);\n          }\n            \n          if (caseInsensitiveData) {\n            console.log('[useTeams] Found league with case-insensitive search:', caseInsensitiveData);\n            // Cache the result\n            localStorage.setItem(cacheKey, JSON.stringify(caseInsensitiveData));\n            setResolvedLeagueId(caseInsensitiveData.id);\n            setIsLeagueResolutionComplete(true);\n          } else {\n            console.warn('[useTeams] No league data found for key (case-insensitive):', leagueKey);\n            setResolvedLeagueId(null);\n            setIsLeagueResolutionComplete(true);\n          }\n        } else {\n          console.log('[useTeams] Found league:', leagueData);\n          // Cache the result\n          localStorage.setItem(cacheKey, JSON.stringify(leagueData));\n          setResolvedLeagueId(leagueData.id);\n          setIsLeagueResolutionComplete(true);\n        }\n      } catch (err) {\n        console.error('[useTeams] Error resolving league ID:', err);\n        setResolvedLeagueId(null);\n        setIsLeagueResolutionComplete(true); // Mark resolution complete even on error\n      }\n    }\n    \n    resolve();\n  }, [leagueKey]);\n\n  // Effect 2: Fetch teams when league ID or resolution status changes\n  useEffect(() => {\n    async function fetch() {\n      // If a leagueKey is specified, wait for its resolution to complete.\n      if (leagueKey && !isLeagueResolutionComplete) {\n        console.log(`[useTeams] Waiting for league resolution of key: '${leagueKey}'.`);\n        // setLoading(true); // Initial loading state should cover this period\n        return;\n      }\n\n      console.log(`[useTeams] Proceeding to fetch teams. LeagueKey: '${leagueKey}', ResolvedId: '${resolvedLeagueId}', ResolutionComplete: ${isLeagueResolutionComplete}`);\n      setLoading(true);\n      setError(null);\n      \n      try {\n        // This log is now part of the general proceeding log above\n        let query = supabase\n          .from('teams')\n          .select('id, external_id, name, city, abbreviation, logo_url, league_id, primary_color, secondary_color, created_at, updated_at')\n          .order('name', { ascending: true });\n          \n        if (resolvedLeagueId) {\n          console.log('[useTeams] Filtering teams by leagueId:', resolvedLeagueId);\n          query = query.eq('league_id', resolvedLeagueId);\n        } else if (leagueKey) {\n          console.warn(`[useTeams] League resolution for key '${leagueKey}' complete but no ID found. Fetching all teams as fallback.`);\n        } else {\n          console.log('[useTeams] No leagueKey provided. Fetching all teams.');\n        }\n        \n        console.log('[useTeams] Executing teams query...');\n        const { data, error: fetchError, count } = await query;\n        \n        if (fetchError) {\n          console.error('[useTeams] Error fetching teams:', fetchError);\n          throw fetchError;\n        }\n        \n        console.log(`[useTeams] Found ${data?.length || 0} teams`);\n        \n        // Transform the data to match our Team interface\n        const formattedTeams = (data || []).map(team => {\n          const formatted = {\n            id: team.id,\n            external_id: team.external_id,\n            name: team.name,\n            city: team.city,\n            abbreviation: team.abbreviation,\n            logo_url: team.logo_url,\n            primary_color: team.primary_color,\n            secondary_color: team.secondary_color,\n            league_id: team.league_id,\n            created_at: team.created_at,\n            updated_at: team.updated_at\n          };\n          // console.log('[useTeams] Team:', formatted); // Too verbose for many teams\n          return formatted;\n        });\n        \n        setTeams(formattedTeams);\n        console.log('[useTeams] Teams state updated with:', formattedTeams.length, 'teams');\n      } catch (err) {\n        console.error('[useTeams] Error in fetchTeams function:', err);\n        setError(err instanceof Error ? err : new Error('Failed to fetch teams'));\n        setTeams([]);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetch();\n  }, [resolvedLeagueId, leagueKey, isLeagueResolutionComplete]);\n\n  // Create a map for quick lookup by team ID\n  const teamMap = useMemo(() => {\n    return teams.reduce((acc, team) => {\n      acc[team.id] = team;\n      return acc;\n    }, {} as Record<string, Team>);\n  }, [teams]);\n  \n  // Create a map for lookup by external_id\n  const teamByExternalId = useMemo(() => {\n    return teams.reduce((acc, team) => {\n      acc[team.external_id] = team;\n      return acc;\n    }, {} as Record<number, Team>);\n  }, [teams]);\n\n  return { \n    teams, \n    teamMap, \n    teamByExternalId,\n    loading, \n    error,\n    resolvedLeagueId,\n    isLeagueResolutionComplete \n  };\n}\n","import { useState, useEffect } from 'react';\nimport { supabase } from '@/lib/supabase';\nimport { Game, Sport, Team as AppTeam } from '../types';\nimport { Database } from '../types/database.types';\n\n// Type for game data coming from Supabase query, including related tables\ntype FetchedGame = Database['public']['Tables']['games']['Row'] & {\n  leagues: { name: string | null; key: string | null } | null;\n  home_team: Database['public']['Tables']['teams']['Row'] | null;\n  away_team: Database['public']['Tables']['teams']['Row'] | null;\n};\n\n// Define the API response type (Note: OddsResponse seems unused in the provided hook logic for mapping games)\ninterface OddsResponse {\n  id: string;\n  sport_key: string;\n  sport_title: string;\n  commence_time: string;\n  home_team: string;\n  away_team: string;\n  home_team_id?: string;\n  away_team_id?: string;\n  bookmakers: Array<{\n    key: string;\n    title: string;\n    last_update: string;\n    markets: Array<{\n      key: string;\n      outcomes: Array<{\n        name: string;\n        price: number;\n        point?: number;\n      }>;\n    }>;\n  }>;\n  status?: string;\n  venue?: string;\n}\n\n\n\n/**\n * Hook to fetch upcoming games from Supabase\n * @param sport The sport to fetch games for (e.g., 'nba', 'mlb')\n * @param limit Maximum number of games to return\n * @returns Object containing games, loading state, and error\n */\nexport interface UseUpcomingGamesOptions {\n  sport?: Sport;\n  limit?: number;\n  offset?: number;\n  date?: string; // ISO date string (YYYY-MM-DD)\n  teamId?: string;\n  leagueId?: string | null; // Allow null for leagueId\n  disabled?: boolean; // Option to disable the hook\n}\n\nexport function useUpcomingGames(options: UseUpcomingGamesOptions = {}) {\n  const [games, setGames] = useState<Game[]>([]); // Uses imported Game type\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [hasMore, setHasMore] = useState<boolean>(true);\n\n  useEffect(() => {\n    const fetchGames = async () => {\n      console.log('[useUpcomingGames] fetchGames called with options:', options);\n      if (options.disabled) {\n        console.log('[useUpcomingGames] Hook is disabled, returning.');\n        setGames([]);\n        setLoading(false);\n        setHasMore(false);\n        setError(null); // Clear any previous error\n        return;\n      }\n      setLoading(true);\n      setError(null);\n\n      // Defaults\n      const {\n        sport = 'all',\n        limit = 10,\n        offset = 0,\n        date,\n        teamId,\n        leagueId,\n      } = options;\n\n      try {\n        let query = supabase\n          .from('games')\n          .select(`\n            id, external_id, league_id, home_team_id, away_team_id, venue_id, game_date, game_time_utc, status, home_score, away_score, home_odds, away_odds, spread, over_under, created_at, updated_at,\n            leagues:league_id(name, key),\n            home_team:home_team_id(*),\n            away_team:away_team_id(*)\n          `)\n          .order('game_time_utc', { ascending: true })\n          .limit(limit)\n          .range(offset, offset + limit - 1);\n\n        // Only upcoming games (scheduled, not started)\n        query = query.gte('game_time_utc', new Date().toISOString())\n                     .eq('status', 'scheduled');\n\n        // Date filter (show only games on a certain date)\n        if (date) {\n          // Get games for the selected date (00:00 to 23:59 UTC)\n          const start = new Date(date + 'T00:00:00Z').toISOString();\n          const end = new Date(date + 'T23:59:59Z').toISOString();\n          query = query.gte('game_time_utc', start).lte('game_time_utc', end);\n        }\n\n        // League filter\n        if (leagueId) query = query.eq('league_id', leagueId);\n        // Team filter\n        if (teamId) query = query.or(`home_team_id.eq.${teamId},away_team_id.eq.${teamId}`);\n\n        // Use league_id for filtering MLB (if provided)\n        if (leagueId) query = query.eq('league_id', leagueId);\n        // Remove sport filter – games table does not have this column\n\n        console.log('[useUpcomingGames] Executing Supabase query for games...');\n        const { data: gamesData, error: gamesError } = await query;\n\n        if (gamesError) {\n          console.error('[useUpcomingGames] Supabase error fetching games:', gamesError);\n          setError(gamesError);\n          setGames([]);\n          setHasMore(false);\n          setLoading(false);\n          return;\n        }\n\n        // If fewer than limit, no more pages\n        setHasMore((gamesData?.length || 0) === limit);\n\n        if (!gamesData || gamesData.length === 0) {\n          console.log('[useUpcomingGames] No gamesData received or gamesData is empty.');\n          setGames([]);\n          setLoading(false);\n          // setHasMore(false); // Already handled by gamesData.length === limit check or implicitly if length is 0\n          return;\n        }\n\n        // Map the database fields to the Game type\n        const mappedGames = gamesData.map((dbGame: FetchedGame): Game => {\n          // Derive sport from league key\n          const sportKeyValue = dbGame.leagues?.key || 'other';\n          let sport: Sport = sportKeyValue as Sport;\n          \n          // Map league key to sport if needed\n          if (sportKeyValue === 'mlb' || sportKeyValue === '4424') sport = 'mlb';\n          else if (sportKeyValue === 'nba' || sportKeyValue === '4387') sport = 'nba';\n          else if (sportKeyValue === 'nfl' || sportKeyValue === '4391') sport = 'nfl';\n          else if (sportKeyValue === 'nhl' || sportKeyValue === '4380') sport = 'nhl';\n          else if (sportKeyValue?.toLowerCase().includes('soccer')) sport = 'soccer';\n          // Add more specific mappings if dbGame.leagues.key is not a direct Sport type\n\n          return {\n            // Core DB fields\n            id: dbGame.id,\n            external_id: dbGame.external_id,\n            league_id: dbGame.league_id,\n            home_team_id: dbGame.home_team_id,\n            away_team_id: dbGame.away_team_id,\n            venue_id: dbGame.venue_id,\n            game_date: dbGame.game_date,\n            game_time_utc: dbGame.game_time_utc,\n            status: dbGame.status,\n            home_score: dbGame.home_score,\n            away_score: dbGame.away_score,\n            home_odds: dbGame.home_odds,\n            away_odds: dbGame.away_odds,\n            spread: dbGame.spread,\n            over_under: dbGame.over_under,\n            // Create odds array for backward compatibility\n            odds: [\n              dbGame.home_odds ? {\n                market: 'Moneyline',\n                outcome: 'Home',\n                price: dbGame.home_odds\n              } : null,\n              dbGame.away_odds ? {\n                market: 'Moneyline',\n                outcome: 'Away',\n                price: dbGame.away_odds\n              } : null,\n              dbGame.spread ? {\n                market: 'Spread',\n                outcome: 'Home',\n                price: dbGame.spread\n              } : null,\n              dbGame.over_under ? {\n                market: 'Total',\n                outcome: 'Over',\n                price: dbGame.over_under\n              } : null\n            ].filter(Boolean),\n            // the_sports_db_id removed as it doesn't exist in the database schema\n            // sport_type removed as it doesn't exist in the database schema\n            created_at: dbGame.created_at,\n            updated_at: dbGame.updated_at,\n\n            // Application-specific/derived fields\n            sport: sport,\n            start_time: (() => {\n              const gameDateStr = dbGame.game_date as string | null;\n              const gameTimeUTCStr = dbGame.game_time_utc as string | null;\n\n              // Log raw inputs for each game being mapped\n              // console.log(`[useUpcomingGames MAPPING] Game ${dbGame.id}: game_date = \"${gameDateStr}\", game_time_utc = \"${gameTimeUTCStr}\"`);\n\n              if (gameDateStr && gameTimeUTCStr) {\n                const datePart = gameDateStr.split('T')[0]; // Extracts \"YYYY-MM-DD\"\n                \n                let timePart: string | null = null;\n                // Regex to find HH:MM:SS with optional timezone at the end of the string\n                const timeRegex = /(\\d{2}:\\d{2}:\\d{2}(?:[+-]\\d{2}:\\d{2}|Z)?)$/;\n                const timeMatch = gameTimeUTCStr.match(timeRegex);\n\n                if (timeMatch && timeMatch[1]) {\n                  timePart = timeMatch[1];\n                } else if (gameTimeUTCStr.includes('T')) {\n                  // Fallback if regex fails but gameTimeUTC is like YYYY-MM-DDTHH:MM:SSZ\n                  const parts = gameTimeUTCStr.split('T');\n                  if (parts.length > 1 && parts[1]) {\n                    timePart = parts[1]; // Takes the HH:MM:SSZ part\n                  }\n                } else if (/^\\d{2}:\\d{2}:\\d{2}(?:[+-]\\d{2}:\\d{2}|Z)?$/.test(gameTimeUTCStr)) {\n                  // If gameTimeUTC is already just a time string like HH:MM:SSZ\n                  timePart = gameTimeUTCStr;\n                }\n\n                if (datePart && timePart) {\n                  const derived = `${datePart}T${timePart}`;\n                  // console.log(`[useUpcomingGames MAPPING] Game ${dbGame.id}: datePart = \"${datePart}\", timePart = \"${timePart}\", derived_start_time = \"${derived}\"`);\n                  if (new Date(derived).toString() === 'Invalid Date') {\n                    // console.warn(`[useUpcomingGames MAPPING] Game ${dbGame.id}: Derived start_time (\"${derived}\") is INVALID. Falling back to game_date.`);\n                    // Fallback to game_date if it's a valid full timestamp, otherwise updated_at\n                    return gameDateStr && new Date(gameDateStr).toString() !== 'Invalid Date' ? gameDateStr : (dbGame.updated_at || new Date().toISOString());\n                  }\n                  return derived;\n                } else {\n                  // console.warn(`[useUpcomingGames MAPPING] Could not parse datePart or timePart for game ${dbGame.id}. gameDateStr: \"${gameDateStr}\", gameTimeUTCStr: \"${gameTimeUTCStr}\". Falling back.`);\n                  // Fallback to game_date if it's a valid full timestamp, otherwise updated_at\n                  return gameDateStr && new Date(gameDateStr).toString() !== 'Invalid Date' ? gameDateStr : (dbGame.updated_at || new Date().toISOString());\n                }\n              } else if (gameDateStr && new Date(gameDateStr).toString() !== 'Invalid Date') {\n                // console.log(`[useUpcomingGames MAPPING] Game ${dbGame.id}: Only game_date available and valid. Using game_date (\"${gameDateStr}\") as start_time.`);\n                return gameDateStr;\n              }\n              \n              // console.error(`[useUpcomingGames MAPPING] Game ${dbGame.id}: Insufficient or invalid date/time info. game_date=\"${gameDateStr}\", game_time_utc=\"${gameTimeUTCStr}\". Using fallback.`);\n              return dbGame.updated_at || new Date().toISOString();\n            })(),\n            league_name: dbGame.leagues?.name || undefined,\n            home_team_name: dbGame.home_team?.name || undefined, // Requires home_team to be fetched object\n            away_team_name: dbGame.away_team?.name || undefined, // Requires away_team to be fetched object\n            \n            // Include the full team objects\n            home_team: dbGame.home_team || undefined,\n            away_team: dbGame.away_team || undefined,\n            \n            // Astro fields - not populated by this hook, GameCard handles undefined\n            // prediction, astroPrediction, confidence, moonPhase, sunSign, dominantElement, astroInfluence, homeEdge\n          };\n        });\n\n        // Add logging here to inspect problematic games\n        mappedGames.forEach(game => {\n          const dateObj = new Date(game.start_time);\n          if (isNaN(dateObj.getTime())) {\n            console.log(`[useUpcomingGames] Problematic game data for Invalid Date (after new derivation):`, {\n              game_id: game.id,\n              original_game_date: game.game_date,         // Directly from mapped game object\n              original_game_time_utc: game.game_time_utc, // Directly from mapped game object\n              updated_at_from_map: game.updated_at, // This was in the log, keeping for consistency       // Directly from mapped game object\n              derived_start_time_attempt: game.start_time,\n            });\n          }\n        });\n\n        console.log('Mapped games:', mappedGames);\n        setGames(mappedGames);\n        setError(null);\n      } catch (err: any) {\n        setError(err);\n        setGames([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchGames();\n  }, [options.sport, options.limit, options.offset, options.date, options.teamId, options.leagueId]);\n\n  return { games, loading, error, hasMore };\n}\n"],"names":["useTeams","leagueKey","teams","setTeams","useState","loading","setLoading","error","setError","resolvedLeagueId","setResolvedLeagueId","isLeagueResolutionComplete","setIsLeagueResolutionComplete","useEffect","resolve","cacheKey","cachedLeague","leagueData","leagueDataArray","leagueFetchError","supabase","leagueError","caseInsensitiveData","caseInsensitiveArray","ilikeError","e","err","fetch","query","data","fetchError","count","formattedTeams","team","teamMap","useMemo","acc","teamByExternalId","useUpcomingGames","options","games","setGames","hasMore","setHasMore","sport","limit","offset","date","teamId","leagueId","start","end","gamesData","gamesError","mappedGames","dbGame","sportKeyValue","_a","gameDateStr","gameTimeUTCStr","datePart","timePart","timeRegex","timeMatch","parts","derived","_b","_c","_d","game","dateObj"],"mappings":"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"}