name: Verify Meta Tags

on:
  schedule:
    # Run weekly on Monday at 2 AM UTC
    - cron: '0 2 * * 1'
  workflow_dispatch:
    # Allow manual triggering
    inputs:
      reason:
        description: 'Reason for manual run'
        required: false
        default: 'Manual trigger'

jobs:
  verify-meta-tags:
    name: Verify Meta Tags
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build application
        run: npm run build
        
      - name: Start local server
        run: npm run preview &
        
      - name: Wait for server to start
        run: sleep 10
        
      - name: Run meta tags verification
        run: npm run check:meta -- --base-url http://localhost:3000
        
      - name: Upload verification report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: meta-tags-report
          path: meta-tags-report.json
          retention-days: 7
          
      - name: Create issue for meta tag issues
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            let report = { summary: { errors: 0 } };
            try {
              report = JSON.parse(fs.readFileSync('meta-tags-report.json', 'utf8'));
            } catch (error) {
              console.error('Error reading report file:', error);
            }
            
            if (report.summary.errors === 0) {
              console.log('No meta tag issues found in report');
              return;
            }
            
            // Create markdown report
            let body = '## üîç Meta Tag Issues Detected\n\n';
            body += `**Total Pages with Issues:** ${report.summary.errors}\n\n`;
            
            // Add sections for each page with issues
            Object.entries(report.pages).forEach(([page, pageData]) => {
              if (pageData.error || pageData.missingTags?.length > 0 || Object.keys(pageData.invalidTags || {}).length > 0) {
                body += `### ${pageData.url}\n`;
                
                if (pageData.error) {
                  body += `- ‚ùå Error: ${pageData.error}\n`;
                }
                
                if (pageData.missingTags?.length > 0) {
                  body += `- ‚ùå Missing tags: ${pageData.missingTags.join(', ')}\n`;
                }
                
                if (pageData.invalidTags) {
                  Object.entries(pageData.invalidTags).forEach(([tag, data]) => {
                    body += `- ‚ö†  Invalid tag: ${tag} (${data.message})\n`;
                    body += `  - Value: ${data.value}\n`;
                  });
                }
                
                body += '\n';
              }
            });
            
            // Add summary of issues
            if (report.summary.missingTags) {
              body += '### Missing Tags Summary\n';
              Object.entries(report.summary.missingTags).forEach(([tag, count]) => {
                body += `- ${tag}: ${count} pages\n`;
              });
              body += '\n';
            }
            
            if (report.summary.invalidTags) {
              body += '### Invalid Tags Summary\n';
              Object.entries(report.summary.invalidTags).forEach(([tag, data]) => {
                body += `- ${tag}: ${data.count} issues\n`;
                Object.entries(data.messages || {}).forEach(([msg, msgCount]) => {
                  body += `  - ${msg} (${msgCount} pages)\n`;
                });
              });
            }
            
            body += '\n---\n';
            body += '*This issue was automatically generated by the meta tag verification workflow.*';
            
            // Create or update issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['bug', 'seo'],
              state: 'open'
            });
            
            const existingIssue = issues.find(issue => 
              issue.title.includes('Meta Tag Issues Detected')
            );
            
            const issueTitle = `üîç Meta Tag Issues Detected (${new Date().toISOString().split('T')[0]})`;
            
            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                title: issueTitle,
                body: body
              });
              console.log(`Updated issue #${existingIssue.number}: ${issueTitle}`);
            } else {
              // Create new issue
              const { data: issue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: body,
                labels: ['bug', 'seo']
              });
              console.log(`Created issue #${issue.number}: ${issueTitle}`);
            }
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
