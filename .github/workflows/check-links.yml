name: Check Links

on:
  schedule:
    # Run weekly on Monday at 1 AM UTC
    - cron: '0 1 * * 1'
  workflow_dispatch:
    # Allow manual triggering
    inputs:
      reason:
        description: 'Reason for manual run'
        required: false
        default: 'Manual trigger'

jobs:
  check-links:
    name: Check for broken links
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run link checker
        run: npm run check:links:ci
        
      - name: Upload link check report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: link-check-report
          path: link-check-report.json
          retention-days: 7
          
      - name: Create issue for broken links
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const report = JSON.parse(fs.readFileSync('link-check-report.json', 'utf8'));
            
            const brokenLinks = report.brokenLinks || [];
            
            if (brokenLinks.length === 0) {
              console.log('No broken links found in report');
              return;
            }
            
            // Group by status code
            const byStatus = brokenLinks.reduce((acc, link) => {
              const status = link.status || 'UNKNOWN';
              acc[status] = acc[status] || [];
              acc[status].push(link);
              return acc;
            }, {});
            
            // Create markdown report
            let body = '## ðŸ”— Broken Links Detected\n\n';
            body += `**Total Broken Links:** ${brokenLinks.length}\n\n`;
            
            Object.entries(byStatus).forEach(([status, links]) => {
              body += `### Status ${status} (${links.length} links)\n`;
              links.forEach(link => {
                body += `- [${link.url}](${link.url})`;
                if (link.text) body += ` - "${link.text}"`;
                body += `\n  - Found on: ${link.foundOn}\n`;
              });
              body += '\n';
            });
            
            body += '---\n';
            body += '*This issue was automatically generated by the link checker workflow.*';
            
            // Create or update issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['bug', 'broken-links'],
              state: 'open'
            });
            
            const existingIssue = issues.find(issue => 
              issue.title.includes('Broken Links Detected')
            );
            
            const issueTitle = `ðŸ”— Broken Links Detected (${new Date().toISOString().split('T')[0]})`;
            
            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                title: issueTitle,
                body: body
              });
              console.log(`Updated issue #${existingIssue.number}: ${issueTitle}`);
            } else {
              // Create new issue
              const { data: issue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: body,
                labels: ['bug', 'broken-links']
              });
              console.log(`Created issue #${issue.number}: ${issueTitle}`);
            }
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
