import { createClient } from '@supabase/supabase-js';
import * as stringSimilarity from 'string-similarity';

class TeamMatchingService {
  constructor(supabase) {
    this.supabase = supabase;
    this.teamCache = new Map();
    this.dataSourceId = 'odds_api_v1';
  }

  async initialize() {
    await this.ensureDataSource();
    await this.cacheTeams();
  }

  async ensureDataSource() {
    const { data, error } = await this.supabase
      .from('data_sources')
      .upsert(
        {
          id: this.dataSourceId,
          name: 'The Odds API',
          version: '1.0'
        },
        { onConflict: 'id' }
      )
      .select()
      .single();

    if (error) {
      console.error('Error ensuring data source:', error);
      throw error;
    }

    return data;
  }

  async cacheTeams() {
    const { data: teams, error } = await this.supabase
      .from('teams')
      .select('id, name, abbreviation, sport, league');

    if (error) {
      console.error('Error caching teams:', error);
      throw error;
    }

    this.teamCache = new Map(teams.map(team => [team.id, team]));
  }

  async findBestTeamMatch(teamName, sport, minConfidence = 0.7) {
    // 1. Try exact match with aliases
    const { data: exactMatches } = await this.supabase
      .from('team_aliases')
      .select('team:teams!inner(*), confidence')
      .eq('alias', teamName)
      .eq('source_id', this.dataSourceId)
      .eq('teams.sport', sport)
      .order('confidence', { ascending: false })
      .limit(1);

    if (exactMatches?.length > 0) {
      return { 
        team: exactMatches[0].team, 
        confidence: exactMatches[0].confidence,
        isExactMatch: true 
      };
    }

    // 2. Try fuzzy match with all teams in the sport
    const teams = Array.from(this.teamCache.values())
      .filter(team => team.sport === sport);

    const matches = teams.map(team => ({
      team,
      score: Math.max(
        stringSimilarity.compareTwoStrings(
          teamName.toLowerCase(), 
          team.name.toLowerCase()
        ),
        team.abbreviation 
          ? stringSimilarity.compareTwoStrings(
              teamName.toLowerCase(),
              team.abbreviation.toLowerCase()
            )
          : 0
      )
    })).filter(m => m.score >= minConfidence)
      .sort((a, b) => b.score - a.score);

    if (matches.length > 0) {
      const bestMatch = matches[0];
      await this.createAlias(
        bestMatch.team.id, 
        teamName, 
        bestMatch.score,
        true
      );
      
      return { 
        team: bestMatch.team, 
        confidence: bestMatch.score,
        isExactMatch: false
      };
    }

    return null;
  }

  async createAlias(teamId, alias, confidence = 1.0, isAutoGenerated = false) {
    const { data, error } = await this.supabase
      .from('team_aliases')
      .upsert({
        team_id: teamId,
        alias,
        source_id: this.dataSourceId,
        confidence,
        is_auto_generated: isAutoGenerated
      }, {
        onConflict: 'alias,source_id'
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating alias:', error);
      throw error;
    }

    return data;
  }

  async findOrCreateTeam(teamName, sport, league) {
    // First try to find a match
    const match = await this.findBestTeamMatch(teamName, sport);
    
    if (match) {
      return {
        ...match.team,
        confidence: match.confidence,
        isNew: false
      };
    }

    // If no match found, create a new team with required fields
    const newTeam = {
      name: teamName,
      sport,
      league,
      abbreviation: this.generateAbbreviation(teamName),
      espn_id: `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    console.log('Creating new team:', newTeam);

    const { data: createdTeam, error } = await this.supabase
      .from('teams')
      .insert(newTeam)
      .select()
      .single();

    if (error) {
      console.error('Error creating team:', error);
      throw error;
    }

    // Add to cache
    this.teamCache.set(createdTeam.id, createdTeam);

    // Create alias
    await this.createAlias(createdTeam.id, teamName, 1.0, false);

    return {
      ...createdTeam,
      confidence: 1.0,
      isNew: true
    };
  }

  generateAbbreviation(name) {
    const words = name.split(' ').filter(Boolean);
    if (words.length === 1) {
      return name.substring(0, 3).toUpperCase();
    }
    return words.map(w => w[0]).join('').toUpperCase().substring(0, 3);
  }
}

export default TeamMatchingService;
